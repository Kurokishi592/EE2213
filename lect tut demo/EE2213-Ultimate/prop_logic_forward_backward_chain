from sympy import symbols
'''
Method 4 and 5: Forward and Backward Chaining (Horn clauses)
- Forward chaining: data-driven application of Modus Ponens on Horn rules until saturation or goal derived.
- Backward chaining: goal-driven recursive search using Modus Ponens on Horn rules.
Only Modus Ponens is used (on Horn implications with a single positive head).
'''
A, B, C, D, E, F = symbols('A B C D E F') # A and B are atomic facts, L is the goal
horn_facts = {C, E} # Initial known facts: A and B are true
horn_rules = [
    (frozenset({B, E}), A),          # B & E -> A
    (frozenset({E}), D),       # E -> D
    (frozenset({D}), B),
    (frozenset({A, C}), F)          
]

# ---------------- Horn utilities ----------------
def _rule_str(premises, head):
    if not premises:
        return f"TRUE -> {head}"
    return f"{' & '.join(map(str, sorted(premises, key=str)))} -> {head}"

def forward_chaining(facts, rules, goal=None, trace=True):
    """Forward chaining on Horn rules.
    facts: set of SymPy symbols initially true
    rules: list of tuples (premises:set of symbols, head:symbol)
    goal: optional symbol to stop early when derived
    Returns (derived_facts:set, success:bool|None)
    """
    known = set(facts)
    fired = set()
    step = 0
    if trace:
        print("\n=== Forward Chaining Trace (Horn) ===")
        print("[FC] Initial facts:", sorted(map(str, known)))
        for i, (prem, head) in enumerate(rules, 1):
            print(f"[FC] Rule R{i}: {_rule_str(prem, head)}")
    changed = True
    while changed:
        changed = False
        for idx, (prem, head) in enumerate(rules, 1):
            if (idx in fired) or (head in known):
                continue
            if prem.issubset(known):
                known.add(head)
                fired.add(idx)
                step += 1
                if trace:
                    print(f"[FC] Step {step}: fire R{idx}: {_rule_str(prem, head)}; add fact {head}")
                changed = True
                if goal is not None and head == goal:
                    if trace:
                        print(f"[FC] Goal {goal} derived.")
                    return known, True
    if goal is not None:
        if trace:
            print(f"[FC] Saturated; goal {goal} {'derived' if goal in known else 'not derived'}.")
        return known, (goal in known)
    return known, None

def backward_chaining(goal, facts, rules, trace=True, depth=0, visited=None):
    """Backward chaining on Horn rules; returns True if goal provable from facts and rules."""
    indent = '  ' * depth
    if visited is None:
        visited = set()
    if goal in facts:
        if trace:
            print(f"{indent}[BC] Goal {goal} is an initial fact.")
        return True
    if goal in visited:
        if trace:
            print(f"{indent}[BC] Already attempted {goal}; avoid loop.")
        return False
    visited.add(goal)
    # Find rules whose head is the goal
    candidates = [(prem, h) for (prem, h) in rules if h == goal]
    if trace:
        print(f"{indent}=== Backward Chaining: prove {goal} ===")
        print(f"{indent}[BC] Found {len(candidates)} rule(s) for {goal}.")
    for prem, _ in candidates:
        if trace:
            need = 'TRUE' if not prem else ' & '.join(map(str, sorted(prem, key=str)))
            print(f"{indent}[BC] Try rule: {_rule_str(prem, goal)}; need {need}.")
        ok = True
        for sub in sorted(prem, key=str):
            if not backward_chaining(sub, facts, rules, trace=trace, depth=depth+1, visited=visited):
                ok = False
                if trace:
                    print(f"{indent}[BC] Failed to prove {sub}; backtrack.")
                break
        if ok:
            if trace:
                print(f"{indent}[BC] Derived {goal} by Modus Ponens.")
            return True
    if trace:
        print(f"{indent}[BC] No rule can derive {goal} with available facts.")
    return False



# # Run forward chaining
# fc_facts, fc_success = forward_chaining(horn_facts, horn_rules, goal=F, trace=True)
# print("[FC] Final facts:", sorted(map(str, fc_facts)))
# print("[FC] Result:", "derived goal" if fc_success else "did not derive goal")

# # Run backward chaining
print("\n=== Backward Chaining Trace (Horn) ===")
bc_success = backward_chaining(F, horn_facts, horn_rules, trace=True)
print("[BC] Result:", "derived goal" if bc_success else "did not derive goal")