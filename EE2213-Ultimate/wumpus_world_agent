import sympy as sp
# Define a 3x3 world
# Define the grid size
grid_size = 3

'''
LOGIC SETUP
'''
# Step 1: Define propositional symbols
P = {} # Pits
W = {} # Wumpus
B = {} # Breeze
S = {} # Stench

for x in range(1, grid_size+1):
    for y in range(1, grid_size+1):
        P[(x, y)] = sp.symbols(f'P_{x}_{y}')
        W[(x, y)] = sp.symbols(f'W_{x}_{y}')
        B[(x, y)] = sp.symbols(f'B_{x}_{y}')
        S[(x, y)] = sp.symbols(f'S_{x}_{y}')

# print(P)

# Step 2: Define rules as logical expressions
def get_neighbors(x, y, grid_size):
    """Return valid neighboring cells (up/down/left/right) in an n x n grid."""
    directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]
    neighbors = [(x + dx, y + dy) for dx, dy in directions]
    """
    Equivalent to:
    neighbors = []
    for dx, dy in directions:
        neighbors.append((x + dx, y + dy))
    """
    return [(nx, ny) for nx, ny in neighbors if 1 <= nx <= grid_size and 1 <= ny <= grid_size]

def Pit_implies_Breeze(x,y,P,B,grid_size):
    """
    Rule: If there is a pit at (x,y), then agent feels a breeze in all adjacent cells.
    P(x,y) => B(x+1,y) ∧ B(x-1,y) ∧ B(x,y+1) ∧ B(x,y-1)
    """
    adjacent_Breeze = sp.And(*[B[adj] for adj in get_neighbors(x, y, grid_size)])
    # *(splat operator) unpacks the list into separate arguments.
    # example: sp.And(*[a,b,c]) is equivalent to sp.And(a,b,c)
    pit_implies_breeze = sp.Implies(P[(x,y)], adjacent_Breeze)
    return pit_implies_breeze

def Breeze_for_Pit(x,y,B,P,grid_size):
    """
    Rule: If there is a breeze at (x,y), then there is a pit in at least one of the adjacent cells.
          If there is a pit in at least one of the adjacent cells of (x,y), then there is a breeze at (x,y).
          B(x,y) ⇔ P(x+1,y) ∨ P(x-1,y) ∨ P(x,y+1) ∨ P(x,y-1)
    """
    adjacent_pit = sp.Or(*[P[adj] for adj in get_neighbors(x, y, grid_size)])
    breeze_for_pit = sp.Equivalent(B[(x,y)], adjacent_pit)
    return breeze_for_pit

def Wumpus_implies_Stench(x,y,W,S,grid_size):
    """
    Rule: If there is a wumpus at (x,y), then agent smells a stench in all adjacent cells.
    W(x,y) => S(x+1,y) ∧ S(x-1,y) ∧ S(x,y+1) ∧ S(x,y-1)
    """
    adjacent_stench = sp.And(*[S[adj] for adj in get_neighbors(x, y, grid_size)])
    wumpus_implies_stench = sp.Implies(W[(x,y)], adjacent_stench)
    return wumpus_implies_stench

def Stench_for_Wumpus(x,y,S,W,grid_size):
    """
    Rule: If there is a stench at (x,y), then there is a wumpus in at least one of the adjacent cells.
          If there is a wumpus in at least one of the adjacent cells of (x,y), then there is a stench at (x,y).
          S(x,y) ⇔ W(x+1,y) ∨ W(x-1,y) ∨ W(x,y+1) ∨ W(x,y-1)
    """
    adjacent_wumpus = sp.Or(*[W[adj] for adj in get_neighbors(x, y, grid_size)])
    stench_for_wumpus = sp.Equivalent(S[(x,y)], adjacent_wumpus)
    return stench_for_wumpus

def at_least_one_pit(P,grid_size):
    return sp.Or(*[P[(x,y)] for x in range(1, grid_size+1) for y in range(1, grid_size+1)])

def at_least_one_wumpus(W,grid_size):
    return sp.Or(*[W[(x,y)] for x in range(1, grid_size+1) for y in range(1, grid_size+1)])

# Step 3: Combine all rules into a knowledge base
rules = set()

for x in range(1, grid_size+1):
    for y in range(1, grid_size+1):
        pit_implies_breeze = Pit_implies_Breeze(x,y,P,B,grid_size)
        rules.add(pit_implies_breeze)
        breeze_for_pit = Breeze_for_Pit(x,y,B,P,grid_size)
        rules.add(breeze_for_pit)
        wumpus_implies_stench = Wumpus_implies_Stench(x,y,W,S,grid_size)
        rules.add(wumpus_implies_stench)     
        stench_for_wumpus = Stench_for_Wumpus(x,y,S,W,grid_size)
        rules.add(stench_for_wumpus)
rules.add(at_least_one_pit(P, grid_size))
rules.add(at_least_one_wumpus(W, grid_size))

# print("\nKnowledge Base Rules:")
# for rule in rules:
#     print(rule)

''' 
AGENT STARTS HERE
'''
KB = rules.copy()
# UPDATE THIS: add percepts and initial conditions to KB
current_loc = (1,1) 
# update knowledge base with percepts and initial conditions.
KB.add(sp.Not(B[current_loc]))
KB.add(sp.Not(S[current_loc]))
KB.add(sp.Not(P[current_loc]))
KB.add(sp.Not(W[current_loc]))

KB_AND=sp.And(*KB)

# ask: is there definitely a wumpus at (2,2), i.e., does KB entail W[2,2]?
query = W[(2,2)]
print("\nQuery: Is there definitely a wumpus at (2,2)?\n")

# check entailment = check if KB AND NOT query is unsatisfiable (contradiction)
entails = not sp.satisfiable(sp.And(KB_AND, sp.Not(query)))

print(entails)

# ask: is there definitely a pit at (2,2), i.e., does KB entail P[2,2]?
query = P[(2,2)]
print("\nQuery: Is there definitely a pit at (2,2)?\n")

# define a function to check if query is definitely true, definitely false, or uncertain given a knowledge base.
def Infer(KB_AND, query):
    entails = not sp.satisfiable(sp.And(KB_AND, sp.Not(query)))
    if entails:
       print(query, "is definitely true.")
    else:
        entails_not = not sp.satisfiable(sp.And(KB_AND, query))
        if entails_not:
            print(query, "is definitely false.")
        else:
            print(query,"is uncertain.")

print(Infer(KB_AND, query))

# Infer about neighbors of current location (1,1) 
# check if there is W or P in neighbouring, false meaning safe to move
current_loc = (1,1)
neighbors= get_neighbors(current_loc[0],current_loc[1],grid_size)

for neighbor in neighbors:
    print(Infer(KB_AND, W[neighbor]))
    print(Infer(KB_AND, P[neighbor]))

# update knowledge base with inference results.
KB.add(sp.Not(P[(2,1)]))
KB.add(sp.Not(W[(2,1)]))
KB.add(sp.Not(P[(1,2)]))
KB.add(sp.Not(W[(1,2)]))

# Move to (2,1) and Infer about neighbors of (2,1)
current_loc = (2,1)
# update knowledge base with percepts.
KB.add(B[current_loc])
KB.add(sp.Not(S[current_loc]))

KB_AND=sp.And(*KB)

neighbors= get_neighbors(current_loc[0],current_loc[1],grid_size)
for neighbor in neighbors:
    print(Infer(KB_AND, W[neighbor]))
    print(Infer(KB_AND, P[neighbor]))